#' Build AnnotationFunction Class with ggplot2
#'
#' @details
#' Both `gganno` and `gganno2` perform identical functions, but `gganno` is not
#' compatible with [Heatmap][ComplexHeatmap::Heatmap].  In such cases, only an
#' empty annotation region will be added. On the other hand, `gganno2` can be
#' seamlessly combined with both [Heatmap][ComplexHeatmap::Heatmap] and
#' [ggheat], although legends will not be extracted.
#'
#' @inheritParams ggheat
#' @param ... Additional arguments passed to `ggfn`.
#' @inheritParams ComplexHeatmap::AnnotationFunction
#' @section ggfn:
#'
#' `ggfn` accept a ggplot2 object with a default data and mapping created by
#' `ggplot(data, aes(.data$.x))` / `ggplot(data, ggplot2::aes(y = .data$.y))`.
#' The original matrix will be converted into a data.frame with another 3
#' columns added:
#' - `.slice`: the slice row (which = "row") or column (which = "column")
#'   number.
#' - `.x`/`.y`: indicating the x-axis (or y-axis) coordinates. Don't use
#'   [coord_flip][ggplot2::coord_flip] to flip coordinates as it may disrupt
#'   internal operations.
#' - `.index`: denoting the row index of the original matrix, where rows are
#'   uniformly considered as observations and columns as variables.
#'
#' @inherit ggheat
#' @seealso [draw-ggAnnotationFunction][draw,ggAnnotationFunction-method]
#' @examples
#' draw(gganno(rnorm(10L), function(p) {
#'     p + geom_point(aes(y = V1))
#' }, height = unit(10, "cm"), width = unit(0.7, "npc")))
#' @return A `ggAnnotationFunction` object.
#' @export
#' @name gganno
gganno <- function(matrix, ggfn, ..., which = NULL,
                   width = NULL, height = NULL) {
    matrix <- build_matrix(matrix)
    ggfn <- allow_lambda(ggfn)
    ggparams <- rlang::list2(...)
    out <- new_anno(
        n = nrow(matrix),
        draw_fn = function(index, k, n) NULL,
        ylim = NULL, which = which, width = width, height = height,
        show_name = FALSE, name = "gganno"
    )
    out <- methods::as(out, "ggAnnotationFunction")
    out@matrix <- matrix
    out@ggfn <- ggfn
    out@ggparams <- ggparams
    out@gginitialized <- FALSE
    out
}

#' @importClassesFrom ComplexHeatmap AnnotationFunction
#' @export
#' @rdname gganno
#' @include ggheat.R
methods::setClass(
    "ggAnnotationFunction",
    slots = list(
        ggfn = "FunctionOrNull",
        ggparams = "list",
        gginitialized = "logical",
        matrix = "matrix"
    ),
    contains = "AnnotationFunction"
)

#' Draw the ggAnnotationFunction Object
#'
#' @param object The [ggAnnotationFunction][gganno] object.
#' @param index A vector of indices.
#' @param k The current slice index for the annotation if it is split.
#' @param n Total number of slices.
#' @param ... Additional arguments passed on to
# [draw-AnnotationFunction][ComplexHeatmap::draw,HeatmapAnnotation-method].
#' @return draw the annotation.
#' @examples
#' draw(gganno(rnorm(10L), function(p) {
#'     p + geom_point(aes(y = V1))
#' }, height = unit(10, "cm"), width = unit(0.7, "npc")))
#' @export
methods::setMethod(
    f = "draw",
    signature = "ggAnnotationFunction",
    definition = function(object, index, k = 1L, n = 1L, ...) {
        if (ht_opt$verbose) {
            cli::cli_inform("annotation generated by {.fn {object@fun_name}}")
        }
        if (missing(index)) index <- seq_len(object@n)
        # This is only used by ComplexHeatmap::Heatmap function
        # since `ggheat` will initialize `gganno` when preparing the main
        # heatmap layout.
        if (k == 1L && !object@gginitialized) {
            order_list <- gganno_get_order_list("ht_main", object@which)
            if (is.null(order_list)) {
                if (n == 1L) {
                    order_list <- list(index)
                } else {
                    cli::cli_abort("Cannot initialize {.cls {object@name}}")
                }
            }
            # we can only supply heatmap matrix when called from `prepare` of
            # heatmap, there is no heatmap matrix when called from draw
            # directly.
            # We're unable to add legends in draw function,
            # we turn off it.
            object <- make_layout(object, order_list, add_legend = FALSE)
        }
        # will create a new viewport
        methods::callNextMethod(
            object = object, index = index,
            k = k, n = n, ...
        )
    }
)

# https://github.com/jokergoo/ComplexHeatmap/blob/7d95ca5cf533b98bd0351eecfc6805ad30c754c0/R/HeatmapList-draw_component.R#L670
# trace back into `draw_heatmap_list()`
# get slice informations from the draw function
gganno_get_order_list <- function(name, axis,
                                  call_target = "draw_heatmap_list") {
    pos <- 2L
    nframes <- sys.nframe() - 1L # total parents
    while (pos <= nframes) {
        env <- parent.frame(pos)
        if (is_from_eheat(env) &&
            exists(name, envir = env, inherits = FALSE) &&
            is_call_from(pos, call_target)) {
            obj <- .subset2(env, name)
            if (methods::.hasSlot(obj, "row_order_list") &&
                methods::.hasSlot(obj, "column_order_list")) {
                return(switch(axis,
                    row = obj@row_order_list,
                    column = obj@column_order_list
                ))
            }
        }
        pos <- pos + 1L
    }
    NULL
}

#' @importFrom ComplexHeatmap make_layout
methods::setMethod(
    "make_layout", "ggAnnotationFunction",
    function(object, order_list, add_legend = TRUE,
             heat_matrix = NULL, id = NULL) {
        if (!object@gginitialized) {
            if (is.null(heat_matrix) &&
                (is.null(object@matrix) || is.function(object@matrix))) {
                if (is.null(id)) {
                    id <- "gganno"
                } else {
                    id <- sprintf("gganno (%s)", id)
                }
                cli::cli_abort(paste(
                    "You must provide a matrix in", id,
                    "in order to draw {.cls {object@name}} directly"
                ))
            }
            if (is.null(object@matrix)) {
                object@matrix <- switch(object@which,
                    row = heat_matrix,
                    column = t(heat_matrix)
                )
            } else if (is.function(object@matrix)) {
                data <- switch(object@which,
                    row = heat_matrix,
                    column = t(heat_matrix)
                )
                object@matrix <- object@matrix(data)
            }
            gganno_elements <- draw_gganno(object, order_list, id = id)

            # we merge the annotation_legend_list with ggplot2 legends -----
            # we'll trace back into `make_layout,HeatmapList` method
            if (add_legend) {
                add_gg_legend_list(
                    "annotation_legend_list",
                    gganno_elements$legend
                )
            }
            object@fun <- gganno_elements$draw_fn
            object@gginitialized <- TRUE
        }
        object
    }
)

#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 aes
draw_gganno <- function(anno, order_list, id) {
    # anno_nm <- id
    if (is.null(id)) {
        id <- "(gganno)"
        fn_id <- "{.fn ggfn}"
    } else {
        id <- sprintf("(gganno: %s)", id)
        fn_id <- sprintf("{.fn ggfn} %s", id)
    }
    which <- anno@which
    # we always regard matrix row as the observations
    matrix <- anno@matrix
    data <- as_tibble0(matrix, rownames = NULL) # nolint
    if (length(order_list) > 1L) {
        with_slice <- TRUE
    } else {
        with_slice <- FALSE
    }
    coords <- data_frame0(
        .slice = rep(
            seq_along(order_list),
            times = lengths(order_list)
        ),
        .index = unlist(order_list, recursive = FALSE, use.names = FALSE),
        .x = seq_along(.data$.index)
    )
    data <- cbind(coords, data[match(coords$.index, seq_len(nrow(data))), ])
    if (which == "row") {
        data <- rename(data, c(.x = ".y"))
        if (with_slice) {
            data <- lapply(split(data, data$.slice), function(subdata) {
                subdata$.y <- reverse_trans(subdata$.y)
                subdata
            })
            data <- do.call(rbind, data)
            data <- as_tibble0(data, rownames = NULL)
        } else {
            data$.y <- reverse_trans(data$.y)
        }
        p <- ggplot(data, aes(y = .data$.y))
    } else {
        p <- ggplot(data, aes(x = .data$.x))
    }
    p <- rlang::inject(anno@ggfn(p, !!!anno@ggparams))
    if (!ggplot2::is.ggplot(p)) {
        cli::cli_abort(
            sprintf("%s must return a {.cls ggplot2} object.", fn_id)
        )
    }
    if (!inherits(p$facet, "FacetNull")) {
        cli::cli_abort(sprintf("Cannot set facet in %s", fn_id))
    }
    if (!inherits(p$coordinates, "CoordCartesian")) {
        cli::cli_abort(paste(
            "Only {.fn coord_cartesian} can be used in", fn_id
        ))
    }
    # prepare scales --------------------------------------
    labels <- rownames(matrix) %||% ggplot2::waiver()
    if (which == "row") {
        facet_params <- list(
            rows = ggplot2::vars(.data$.slice),
            scales = "free_y", space = "free_y"
        )
        y_scale <- eheat_scales(coords[c(1L, 3:2)], labels,
            scale_fn = ggplot2::scale_y_continuous
        )
        if (!is.null(p$scales$get_scales("y"))) {
            cli::cli_warn(paste("will omit y-scale for row annotation", id))
        }
        if (!is.null(x_scale <- p$scales$get_scales("x"))) { # from user
            # avoid the warning message: Attempting to add facetted x
            # scales, while x scales are not free.
            facet_params$scales <- "free"
        }
        # we always omit the position scales
        p$scales <- p$scales$non_position_scales()
    } else {
        facet_params <- list(
            cols = ggplot2::vars(.data$.slice),
            scales = "free_x", space = "free_x"
        )
        x_scale <- eheat_scales(coords[c(1L, 3:2)], labels,
            scale_fn = ggplot2::scale_x_continuous
        )
        if (!is.null(p$scales$get_scales("x"))) {
            cli::cli_warn(paste("will omit x-scale for column annotation", id))
        }
        if (!is.null(y_scale <- p$scales$get_scales("y"))) { # from user
            # avoid the warning message: Attempting to add facetted y
            # scales, while y scales are not free.
            facet_params$scales <- "free"
        }
        p$scales <- p$scales$non_position_scales()
    }
    # add scales into ggplot2 object ---------------------
    if (with_slice) {
        p <- p + do.call(ggplot2::facet_grid, facet_params)
        p <- p + ggh4x::facetted_pos_scales(x = x_scale, y = y_scale)
    } else {
        # it's safe to add `NULL` or a `list`
        p <- p + x_scale + y_scale
    }

    gt <- ggplot2::ggplotGrob(p) # nolint
    inside_guides <- get_guides(gt, margins = "i")
    draw_fn <- function(index, k, n) {
        vp <- flip_viewport(which, xscale = c(0.5, n + 0.5), yscale = c(0, 1))
        if (with_slice) {
            m <- NULL
            if (which == "row") {
                pattern <- c("panel-%d-1")
                if (k == 1L) {
                    m <- "t"
                } else if (k == n) {
                    m <- "b"
                }
            } else {
                pattern <- "panel-1-%d"
                if (k == 1L) {
                    m <- "l"
                } else if (k == n) {
                    m <- "r"
                }
            }
            pattern <- sprintf(pattern, k)
        } else {
            pattern <- "panel"
            if (which == "row") {
                m <- c("t", "b")
            } else {
                m <- c("l", "r")
            }
        }
        .ggfit(
            gt_area(gt, pattern, margins = m),
            align_with = "panel", margins = m,
            elements = c("axis", "lab"),
            vp = vp
        )
        # in the last slice, we draw inside guides
        if (k == n && length(inside_guides)) {
            # current viewport: `draw,AnnotationFunction` function
            # parent viewport - 1: `draw,HeatmapAnnotation` function
            # parent viewport - 2: `draw,HeatmapAnnotation` function
            # parent viewport - 3: `draw_annotation` function
            # parent viewport - 4: `draw-internal` heatmap  function
            # parent viewport - 5: `draw-internal` heatmap  function

            # https://github.com/jokergoo/ComplexHeatmap/blob/7d95ca5cf533b98bd0351eecfc6805ad30c754c0/R/HeatmapList-draw_component.R#L668
            # parent viewport - 6: `draw_heatmap_list` function

            # parent viewport - 7: `draw_heatmap_list` function
            #   -- "heatmap_{object@name}"
            # parent viewport - 8: `draw_heatmap_list` function
            #   -- "main_heatmap_list"
            # if (n == 1L) {
            #     annotation_global_vp <- grid::current.parent(5L)$name
            # } else {
            #     annotation_global_vp <- grid::current.viewport()$name
            # }
            # .eheat_decorate(annotation_global_vp, {
            #     lapply(inside_guides, grid::grid.draw)
            # })
            if (n == 1L) {
                with_viewport(vp, lapply(inside_guides, grid::grid.draw))
            } else {
                cli::cli_warn(paste(
                    "Cannot draw the inside guides for {which} annotation",
                    "in multiple {which} slices"
                ))
            }
        }
    }
    list(legend = make_legends(gt), draw_fn = draw_fn)
}
