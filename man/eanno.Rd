% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eanno.R
\docType{class}
\name{eanno}
\alias{eanno}
\alias{ExtendedAnnotation-class}
\alias{make_layout,ExtendedAnnotation-method}
\title{Constructor of AnnotationFunction Class}
\usage{
eanno(
  draw_fn,
  ...,
  matrix = NULL,
  which = NULL,
  subset_rule = NULL,
  width = NULL,
  height = NULL,
  show_name = TRUE,
  legends_margin = NULL,
  legends_panel = NULL,
  fun_name = NULL
)

\S4method{make_layout}{ExtendedAnnotation}(object, order_list, ..., heat_matrix = NULL, name = NULL)
}
\arguments{
\item{draw_fn}{A function which defines how to draw the annotation. See
\href{https://jokergoo.github.io/ComplexHeatmap-reference/book/heatmap-annotations.html#implement-new-annotation-functions}{ComplexHeatmap Manual}
for details.

The function must have at least three arguments: \code{index}, \code{k} and \code{n} (the
names of the arguments can be arbitrary) where \code{k} and \code{n} are optional.
\code{index} corresponds to the indices of rows or columns of the heatmap. The
value of \code{index} is not necessarily to be the whole row indices or column
indices in the heatmap. It can also be a subset of the indices if the
annotation is split into slices according to the split of the heatmap.
\code{index} is reordered according to the reordering of heatmap rows or columns
(e.g. by clustering). So, \code{index} actually contains a list of row or column
indices for the current slice after row or column reordering.

k corresponds to the current slice and n corresponds to the total number of
slices.

You can always use \code{self} to indicates the matrix attached in this
annotation.}

\item{...}{Additional arguments passed on to \code{draw_fn}. Only named arguments
can be subsettable.}

\item{matrix}{A matrix, if it is a simple vector, it will be converted to a
one-column matrix. Data.frame will also be coerced into matrix. If \code{NULL},
the matrix from heatmap will be used. You can also provide a function to
transform the matrix.}

\item{which}{Whether it is drawn as a column annotation or a row annotation?}

\item{subset_rule}{A list of function to subset variables in \code{...}.}

\item{width}{The width of the plotting region (the viewport) that the annotation is drawn. If it is a row annotation, the width must be an absolute unit. Since the \code{AnnotationFunction} object is always contained by the \code{\link[ComplexHeatmap]{SingleAnnotation-class}}object, you can only set the width of row annotations or height of column annotations, while e.g. the height of the row annotation is always \code{unit(1, "npc")} which means it always fully filled in the parent \code{SingleAnnotation} and only in \code{\link[ComplexHeatmap]{SingleAnnotation}} or even \code{\link[ComplexHeatmap]{HeatmapAnnotation}} can adjust the height of the row annotations.}

\item{height}{The height of the plotting region (the viewport) that the annotation is drawn. If it is a column annotation, the width must be an absolute unit.}

\item{show_name}{It is used to turn off the drawing of annotation names in \code{\link[ComplexHeatmap]{HeatmapAnnotation}}. Annotations always have names associated and normally they will be drawn beside the annotation graphics to tell what the annotation is about. e.g. the annotation names put beside the points annotation graphics. However, for some of the annotations, the names are not necessarily to be drawn, such as text annotations drawn by \code{\link[ComplexHeatmap]{anno_text}} or an empty annotation drawn by \code{\link[ComplexHeatmap]{anno_empty}}. In this case, when \code{show_names} is set to \code{FALSE}, there will be no annotation names drawn for the annotation.}

\item{legends_margin, legends_panel}{A list of
\link[ComplexHeatmap:Legends-class]{Legends} objects. \code{legends_margin} will be
added in the \code{annotation_legend_list} of
\link[ComplexHeatmap:draw-HeatmapList-method]{draw}. \code{legends_panel} will be
plotted in the annotation panel. See \link[ComplexHeatmap:Legend]{Legend} for
details. Only object with \link{make_legends} methods can be put in
\code{legends_margin}. Only object with \link[=draw-method]{draw} methods can be put in
\code{legends_panel}.}

\item{fun_name}{Name of the annotation function, only used for message.}

\item{object}{An \link[=eanno]{ExtendedAnnotation} object.}

\item{order_list}{Heatmap order list (column/row) after clustering.}

\item{heat_matrix}{Heatmap matrix.}

\item{name}{A string, the name of the annotation.}
}
\value{
A \code{\link[ComplexHeatmap]{AnnotationFunction-class}} object which can be used in \code{\link[ComplexHeatmap]{HeatmapAnnotation}}.
}
\description{
Constructor of AnnotationFunction Class
}
\details{
\code{eanno} is similar with
\link[ComplexHeatmap:AnnotationFunction]{AnnotationFunction}, but \code{eanno} won't
change the function environment of \code{draw_fn}. So it's safe to use \code{eanno} in
pacakge development, particularly when dealing with internal functions in the
package namespace. In addition, all data has been attached in this object.
}
\examples{
x <- 1:10
anno <- eanno(
    draw_fn = function(index, k, n) {
        n <- length(index)
        pushViewport(viewport(xscale = c(0.5, n + 0.5), yscale = c(0, 10)))
        grid.rect()
        grid.points(1:n, x[index], default.units = "native")
        if (k == 1) grid.yaxis()
        popViewport()
    },
    height = unit(2, "cm")
)
m <- rbind(1:10, 11:20)
eheat(m, top_annotation = HeatmapAnnotation(foo = anno))
eheat(m, top_annotation = HeatmapAnnotation(foo = anno), column_km = 2)

anno <- eanno(
    function(index, k, n, self) {
        n <- length(index)
        pushViewport(viewport(xscale = c(0.5, n + 0.5), yscale = c(0, 10)))
        grid.rect()
        grid.points(1:n, self[index], default.units = "native")
        if (k == 1) grid.yaxis()
        popViewport()
    },
    matrix = rnorm(10L), subset_rule = TRUE,
    height = unit(2, "cm")
)
draw(anno)
draw(anno[1:2])
}
\seealso{
\link[ComplexHeatmap:AnnotationFunction]{AnnotationFunction}
}
